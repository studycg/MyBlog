此篇对应《C++ Primer Plus》中的第九章

# 内存模型和名称空间

# 单独编译

**单独编译**的核心思想是：**分而治之**。我们将程序拆分成多个组件，每个组件单独编译成“半成品”，最后再把它们“拼装”起来。

### 1.头文件与源文件

| **文件类型** | **后缀名**     | **存放内容**                                                 | **作用**                                                     |
| ------------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **头文件**   | `.h` / `.hpp`  | **声明：** 1. 函数原型 2. 类声明 (`class {...};`) 3. 结构体声明 4. 模板声明 5. `inline` 函数定义 | **接口契约**。告诉编译器“有这么个东西，长这样”，但不占用内存，不生成实际机器码。 |
| **源文件**   | `.cpp` / `.cc` | **定义：** 1. 函数的具体代码实现 2. 类成员函数的实现 3. 全局变量的定义 | **实现细节**。真正生成二进制机器指令的地方，分配内存。       |

### 2.从源代码到可执行程序

#### 第一步：预处理

- **指令：** `#include "myhead.h"`
- **动作：** 这是一个纯文本操作。预处理器找到 `myhead.h`，把它的内容**原封不动地复制粘贴**到 `.cpp` 文件中 `#include` 的位置。
- **结果：** 生成一个巨大的、临时的“翻译单元”。

#### 第二步：编译 —— 这里的关键是“单独”

- **动作：** 编译器单独处理每一个翻译单元（即每个 `.cpp`）。
- **特点：** 编译器在编译 `a.cpp` 时，**完全不知道** `b.cpp` 的存在。
  - 如果 `a.cpp` 调用了 `b.cpp` 里的函数，编译器怎么知道对不对？
  - 靠 **头文件**！头文件里的**函数原型**就是“空头支票”。编译器看到原型后说：“好，我相信在这个程序的某个地方有这个函数的定义，我先生成一个‘未解析的符号调用’留在这里，让后面的人去填坑。”
- **产物：** 目标文件（`.obj` 或 `.o`）。这是一堆机器码，但里面的函数调用地址还是空的。

#### 第三步：链接 —— 拼装现场

- **动作：** 链接器登场。它把所有的 `.obj` 文件收集起来。
- **填坑：** 它扫描所有 `.obj`，如果发现 `a.obj` 里有个“未解析的符号 `func`”，它就在 `b.obj` 里找到了 `func` 的实际地址，然后把 `a.obj` 里的空缺填上。
- **产物：** 最终的可执行文件 (`.exe`)。

### 3.头文件卫士

- `A.h` 定义了一个结构体 `struct Node { ... };`
- `B.h` 包含了 `A.h` (`#include "A.h"`)
- `main.cpp` 同时包含了 `A.h` 和 `B.h`

**预处理后的后果：** `main.cpp` 里会被复制进去**两份** `struct Node` 的定义。编译器看到同一个文件里定义了两个名字一样的结构体，直接报错：“重定义”。

所以采用了底层防御

~~~c++
#ifndef COORDIN_H_  // 1. 检查标记：如果没有定义过 COORDIN_H_
#define COORDIN_H_  // 2. 设立标记：定义它

// ... 头文件内容 ...

#endif              // 3. 结束
~~~

当编译器第一次遇到这个文件，标记不存在，于是读取内容并设立标记。第二次遇到（通过其他路径包含），标记已存在，直接跳过。

### 4.单定义规则（ODR）的限制

为什么不能把函数**定义**写在头文件里？

1. 如果在 `tool.h` 里写了 `void func() { x++; }`。
2. `a.cpp` 包含 `tool.h` $\rightarrow$ 编译生成 `a.obj`，里面包含一份 `func` 的机器码（符号名为 `_func`）。
3. `b.cpp` 也包含 `tool.h` $\rightarrow$ 编译生成 `b.obj`，里面**也**包含一份 `func` 的机器码（符号名也是 `_func`）。
4. **链接错误！** 链接器在合并 `a.obj` 和 `b.obj` 时，发现两个都叫 `_func` 的强符号，不知道该用哪个，报 **"Multiple Definition"** 错误。

**例外：**

- **`inline` 函数**：允许在头文件中定义。因为内联函数是直接嵌入的，不会生成独立的函数符号供链接器连接。
- **模板 (Templates)**：通常必须写在头文件中。

# 存储持续性、作用域和链接性

## C++的存储方案

**自动存储持续性**：函数内部的变量。

**静态存储持续性**：全局变量或 `static` 变量。与程序共存亡。

**动态存储持续性**：`new` / `delete`。完全由你控制。

*(C++11 新增)* **线程存储持续性**：`thread_local`。随线程生死。

## 作用域和链接性

**作用域**

这是一个**编译时**的概念，描述了代码中可以访问该标识符的**物理区域**。

- **局部作用域**：只在定义它的 `{ ... }` 代码块内可见。
- **全局作用域**：从定义点开始，到文件结束都可见。
- **函数原型作用域**：只在括号里有效（比如 `void func(int n);` 里的 `n`，出了括号就没意义了）。
- **类作用域**：在类内部可见。
- **名称空间作用域**：在 `namespace` 内可见。

**链接性**

这是一个**链接时**的概念，描述了**不同编译单元（.cpp 文件）** 之间如何共享同一个名字。

- **外部链接性：不仅本文件能用，其他文件也能用（需要 `extern`）。就像**公共路灯**。
- **内部链接性：只有本文件能用，其他文件看不见。就像**自家客厅的灯**。
- **无链接性：只有当前代码块能用，连本文件的其他函数都看不见。就像**手电筒**。

## 自动存储持续性

### 特征

- **作用域**：局部（代码块）。
- **链接性**：无。
- **持续性**：自动。执行到声明时分配内存，离开代码块时自动释放。

### 底层原理：栈与 栈帧 (顶)

为什么叫“自动”？因为它利用了 CPU 和内存的**栈结构**机制。

- **入栈 (Push)**：当函数被调用时，操作系统会在栈顶开辟一块区域，称为**栈帧**。所有在这个函数里定义的“自动变量”，都是在这个栈帧里挨个排列的。
- **出栈 (Pop)**：当函数执行结束（遇到 `}`），CPU 只需要把栈指针往回一缩。整个栈帧瞬间被“销毁”（实际上数据还在，只是被标记为无效，随时会被覆盖）。

> **💡 深度点：为什么它快？** 相比于堆（Heap）内存分配需要搜索空闲块、维护链表等复杂操作，栈变量的分配仅仅是寄存器做了一次加减法指令（`SP = SP - size`），速度极快。

### 变量遮挡

~~~c++
int x = 10; // 这里的 x 是 #1
{
    int x = 20; // 这里的 x 是 #2，它"遮挡"了 #1
    cout << x;  // 输出 20
}
cout << x;      // 输出 10，#2 已经销毁，#1 重见天日
~~~

**编译器视角**：编译器在查找符号时，是从当前最内层向外查找的，找到第一个匹配的就停止。

## 静态持续变量

**外部链接性**（全局变量）：（所有文件）

**内部链接性**（静态全局变量）：（本文件）

**无链接性**（静态局部变量）：（函数内）

特点：

**寿命长**：它们在程序运行的一开始就被分配了内存，直到程序结束才释放。

**住在数据段**：它们不占用栈（Stack）空间，而是住在 `.data`（已初始化）或 `.bss`（未初始化）段。

**零初始化**：这是重点！如果忘了初始化自动变量，它的值是垃圾值；但如果忘了初始化静态变量，**编译器会自动把所有的位设置为 0**。

## 静态连续性、外部链接性

`extern`关键字

### 定义域声明

~~~c++
// file1.cpp
double warming = 0.3; // 定义 (Definition)

// file2.cpp
// 这里的 extern 必不可少！
extern double warming; // 声明 (Declaration)
void update() {
    warming += 0.1; // 修改的是 file1.cpp 里的那个 warming
}
~~~

~~~c++
template <typename T>
using Duo = std::pair<T, T>; // 定义一个无论如何两个类型都一样的模板
pair Duo<int> coordinates; // 相当于 std::pair<int, int>
~~~

C++ 规定：**变量只能有一次“定义”，但可以有多次“引用声明”**。

- **`double warming = 0.3;`** 是**定义**（分配内存）。
- **`extern double warming;`** 是**声明**（不分配内存，只是告诉编译器去别处找）。

**常见错误：** 如果在 `file2.cpp` 里写了 `double warming;`（没加 extern），这就变成了**定义**。链接器连接 `file1` 和 `file2` 时，会发现两个 `warming`，直接报错“重定义”。

## 静态持续性、内部链接性

如果我们想定义一个全局变量，但**不想**让其他文件修改它，怎么办？ 答案是：在全局变量前加 `static`。

### 1. 作用

这就相当于给变量加上了 `private` 属性，限制它**只能在当前 `.cpp` 文件内**被访问。

### 2. 隐藏全局变量 (Shadowing)

这是一个非常巧妙的用法。如果 `file1.cpp` 定义了一个全局变量 `x`，而 `file2.cpp` 也定义了一个 `static` 的全局变量 `x`。

C++

```c++
// file1.cpp
int x = 20; // 外部链接

// file2.cpp
static int x = 50; // 内部链接，它"隐藏"了 file1 的 x
// 在 file2 内部，x 永远是 50。它不会与 file1 的 x 发生冲突。
```

**底层原理：** 编译器在处理 `file2.cpp` 时，把 `x` 标记为**本地符号**。链接器在连接时，根本看不到 `file2` 里的 `x`，所以不会报冲突。

## 静态存储持续性、无链接性

这是 `static` 用在函数内部的情况，也是最神奇的一种。

### 1. 语法与行为

```c++
void count_calls() {
    static int count = 0; // 静态局部变量
    count++;
    std::cout << "我被调用了 " << count << " 次" << std::endl;
}

int main() {
    count_calls(); // 输出 1
    count_calls(); // 输出 2
    count_calls(); // 输出 3
}
```

### 2. 核心疑问：它不是局部变量吗？

- **作用域**：是的，它只在 `count_calls` 函数的大括号 `{}` 里可见。出了这个函数，你没法访问它。
- **寿命**：**不是**！它不存储在栈帧里。它存储在静态数据区。
- **初始化**：`static int count = 0;` 这行代码**只会执行一次**！程序启动时初始化一次，以后再调用函数，这行代码直接被跳过。

| **类型**     | **声明位置** | **关键字** | **存储位置** | **寿命**     | **作用域** | **链接性**              |
| ------------ | ------------ | ---------- | ------------ | ------------ | ---------- | ----------------------- |
| **自动变量** | 函数内部     | 无 (auto)  | 栈 (Stack)   | 函数执行期间 | 代码块内   | 无                      |
| **全局变量** | 函数外部     | 无         | 数据段       | 整个程序     | 全文件     | **外部** (全程序可见)   |
| **静态全局** | 函数外部     | **static** | 数据段       | 整个程序     | 全文件     | **内部** (仅本文件可见) |
| **静态局部** | 函数内部     | **static** | 数据段       | 整个程序     | 代码块内   | **无** (仅函数内可见)   |

### 初始化时机

**静态变量到底什么时候被初始化？**

1. **静态初始化 (Static Initialization)**： 对于简单的字面量（如 `static int x = 10;`），在编译期间就确定了，程序加载时直接写入内存。
2. **动态初始化 (Dynamic Initialization)**： 如果初始值需要计算（如 `static double x = std::sqrt(2.0);`），或者是一个类对象。
   - **全局/静态全局**：在 `main()` 函数执行**之前**初始化。
   - **静态局部**：在程序**第一次执行到该变量定义语句**时初始化。

## 说明符和限定符volatile/mutable/extern

**cv限定符**

C++ 里有两个特殊的词被称为 **cv-限定符 (cv-qualifiers)**：

1. **`const`**：常量（我们已经很熟了）。
2. **`volatile`**：易变的（这是底层的重头戏）。

此外还有一个特殊的存储说明符：**`mutable`**。

### `const` 的一个隐蔽陷阱

我们之前学过，全局变量默认是**外部链接性**的（其他文件可见）。 **但是**，**`const` 全局变量默认是内部链接性的！**

```c++
// file1.cpp
const int fingers = 10; // 相当于 static const int fingers = 10;
```

**为什么要这样设计？** 因为 `const` 变量通常被放在头文件中。如果它是外部链接的，当多个 `.cpp` 包含同一个头文件时，链接器会报“重定义错误”。把它设为内部链接，每个包含它的文件都拥有一份独立的、私有的拷贝，就不会打架了。

### `volatile`：我们要和硬件对话

这个关键字是嵌入式开发和驱动开发的神器。它告诉编译器：**“不要优化我！不要把我的值缓存在寄存器里！每次都要老老实实去内存里读！”**

**底层原理：编译器的自作聪明** 编译器为了快，会做这种优化：

~~~c++
int x = 10;
while (x == 10) {
    // 做一些不修改 x 的事情
}
~~~

编译器会想：“既然循环里没人改 `x`，那我把它读到 CPU 寄存器里，以后只检查寄存器就行了，不用每次都跑去内存读。”

**问题场景：** 如果 `x` 并不是一个普通的变量，而是一个**硬件状态寄存器的映射地址**（比如某个传感器的值，它会由硬件自动修改，而不是由代码修改）。 如果编译器只看寄存器里的缓存（一直是 10），它就永远发现不了传感器已经变成了 11。程序就死循环了。

**解决方案：**

~~~c++
volatile int x = 10; // 警告编译器：x 随时可能被外面（硬件/中断）改掉
~~~

加上 `volatile`，编译器就会被迫生成指令，每次通过总线去读取真实的内存地址。

### `mutable`：Const 里的叛徒

有些时候，我们定义了一个 `const` 的结构体或类对象，意味着“逻辑上”它是不变的。但我们在底层可能需要修改它的某个成员（比如为了记录“被访问了多少次”的计数器，或者是缓存标志）。

~~~c++
struct Data {
    char name[30];
    mutable int access_count; // 可变的！
};

int main() {
    const Data d = {"Gemini", 0};
    // d.name[0] = 'A';  // ❌ 错误：d 是 const
    d.access_count++;    // ✅ 正确：access_count 是 mutable
}
~~~

### 其它疑问

`#ifndef`是编译时的机制，ODR违反的是链接问题。

假设const是外部链接

~~~c++
// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H
const int BUFFER_SIZE = 1024;  // 假设const默认是外部链接
#endif

// file1.cpp
#include "constants.h"
void func1() { int a = BUFFER_SIZE; }

// file2.cpp  
#include "constants.h"
void func2() { int b = BUFFER_SIZE; }
~~~

**编译阶段**（每个文件独立）：

- file1.cpp`编译：看到`BUFFER_SIZE = 1024`，在`file1.obj`中生成一个**外部链接**的符号定义
- `file2.cpp`编译：看到`BUFFER_SIZE = 1024`，在`file2.obj`中生成一个**外部链接**的符号定义
- `#ifndef`成功阻止了同一个`.cpp`文件多次包含，但file1和file2是**分开编译**的，每个都获得了自己的定义

**链接阶段**（合并所有.obj文件）：

- 链接器看到：`file1.obj`定义了`BUFFER_SIZE`，`file2.obj`也定义了`BUFFER_SIZE`
-  违反ODR：同一个外部链接符号有**多个定义**
- 链接器报错：`multiple definition of 'BUFFER_SIZE'`

但因为实际上是内部链接，所以编译后都是**内部链接**的符号定义。

编译阶段：

- `file1.obj`：生成一个**内部链接**的`BUFFER_SIZE`（标记为local）
- `file2.obj`：生成一个**内部链接**的`BUFFER_SIZE`（标记为local）

链接阶段：

- 链接器看到两个**不同的局部符号**，虽然同名但互不冲突
- ✅ 链接成功

这里a和b的地址是不同的

**编译阶段（独立进行）**：

- 编译器处理 `a.cpp`：看到 `const int number = 12;`，在`a.obj`中创建一个**内部链接**符号`number`，分配地址A
- 编译器处理 `b.cpp`：看到 `const int number = 12;`，在`b.obj`中创建另一个**内部链接**符号`number`，分配地址B
- 每个`.obj`文件中的`number`都是独立的

**链接阶段**：

- 链接器看到两个名为`number`的符号，但标记为"内部链接"（或静态的）
- 链接器将它们视为**不同的局部符号**，不冲突
- 最终可执行文件中存在**两个独立的`number`变量**，有各自的地址

## 函数和链接性

1. **默认外部**：普通函数默认就是**外部链接性**的。在 `a.cpp` 写个 `void func()`，在 `b.cpp` 只要声明一下就能用。
2. **static 内部**：如果你在一个函数前加 `static`（如 `static void func()`），它就变成了**文件私有**。
   - **用途**：防止污染全局命名空间。你在自己文件里写的辅助函数，最好都加上 `static`，避免和别人写的同名函数冲突。
3. **inline 函数**：不受单定义规则（ODR）限制，可以在头文件中定义。

## 语言和连接性

问题根源：名称修饰

我们在讲函数重载时提到过：

- **C 语言**：`void func(int)` $\rightarrow$ 符号名为 `_func`。
- **C++**：`void func(int)` $\rightarrow$ 符号名为 `_Z4funci`（为了支持重载，加上了参数信息）。

场景：假设你有一个 C 语言写的库（math.c 编译出的 math.lib），里面有个函数 spiff。它的符号名是 _spiff。

你在 C++ 代码里调用它：

~~~c++
// main.cpp (C++)
spiff(5);
~~~

C++ 编译器会把它翻译成调用 `_Z5spiffi`。 **链接阶段崩溃**：链接器拿着 `_Z5spiffi` 去 `math.lib` 里找，根本找不到！因为那里只有 `_spiff`。

解决方案：`extern "C"`

我们需要告诉 C++ 编译器：“嘿，这个函数是用 C 语言风格编译的，你生成符号名的时候，**不要 Mangling（不要乱改名）**，直接用原名！”

~~~c++
extern "C" void spiff(int); // 使用 C 语言链接性
extern "void" spiff(int);   // 使用 C++ 默认链接性（通常省略）
extern "C++" spiff(int);    // 显式指定 C++（和上面一样）
~~~

**通用写法（头文件技巧）：** 你经常在 C 语言库的头文件中看到这种写法，这是为了让它可以同时被 C 和 C++ 项目引用：

~~~c++
#ifdef __cplusplus
extern "C" {
#endif

    void spiff(int);
    void baff(int);

#ifdef __cplusplus
}
#endif
~~~

## 存储方案和动态分配

### 常规`new`运算符

~~~c++
int *pn = new int; // 1. 在堆(Heap)中找到一块足够大的空闲内存
                   // 2. 调用构造函数（如果是类对象）
                   // 3. 返回这块内存的地址
~~~

**内存来源**：堆（Heap）。

**管理**：程序员必须手动 `delete pn`，否则内存泄漏。

**初始化 (C++11)**：

- `int *pi = new int(6);`  // 值初始化为 6
- `int *pi = new int{6};`  // 列表初始化 (C++11)
- `struct where {double x; double y;};`
- `where *one = new where{2.5, 5.3};` // 结构体列表初始化

### 定位`new`运算符

`new` 负责两件事：**找内存** + **构造对象**。 但是，在某些极端的底层场景下（比如编写内存池、嵌入式系统、或者追求极致性能的游戏引擎），我们可能**已经有一块内存了**，我们只是想在这块**已有的内存**上构建一个对象。

这时候就需要 **Placement new**。

#### 语法

需要包含头文件 `<new>`。

~~~c++
#include <new>

char buffer[512]; // 1. 我们预先准备了一块静态内存（比如在栈上或数据段）

int main() {
    double *pd1, *pd2;

    // 常规 new：去堆里找房子
    pd1 = new double; 

    // 定位 new：不去堆里找了，直接住进 buffer 里
    pd2 = new (buffer) double; 
}
~~~

- `pd2` 的值将等于 `buffer` 的地址。

- 它**没有**向堆申请新内存，它只是在 `buffer` 这块地皮上盖了房子。

#### 底层原理

普通的 `new` 操作符会在底层调用 `malloc`（或类似的分配器）来向操作系统请求内存，这是一个相对昂贵的操作（涉及到系统调用、查找空闲链表等）。

**Placement new 的开销几乎为 0**。它仅仅是把对象的数据拷贝到你指定的地址，并调用构造函数。它省去了向 OS 申请内存的时间。

### 析构去释放

> [!WARNING]
>
> **规则：千万不要对 Placement new 的指针使用 `delete`！**

**原因（底层原理）：** `delete` 操作符不仅仅是调用析构函数，它还会试图把这块内存**归还给堆管理器**（free）。 但是 `pd2` 指向的内存是 `buffer`（静态数组），它压根就不属于堆！你试图把一块静态区的内存“还”给堆管理器，堆管理器会一脸懵逼，随即导致程序崩溃（Segmentation Fault 或 Heap Corruption）。

**正确做法：显式调用析构函数**

既然内存不是分配来的，我们不需要“释放”内存，但我们仍然需要“清理”对象（如果对象内部申请了资源）。我们需要**手动调用析构函数**。
~~~
// 假设 JustTesting 是一个类
JustTesting *pc = new (buffer) JustTesting("Bad Idea", 6);

// ... 使用对象 ...

// ✅ 正确销毁步骤：
pc->~JustTesting(); // 1. 手动调用析构函数
// 2. 内存不需要释放，因为 buffer 是自动/静态的，会自动消失
~~~

| **特性**     | **常规 new**        | **定位 new (Placement new)**       |
| ------------ | ------------------- | ---------------------------------- |
| **内存来源** | 堆 (Heap)           | 你提供的缓冲区 (Stack/Static/Heap) |
| **主要开销** | 寻找空闲内存 + 构造 | 仅构造 (极快)                      |
| **释放方式** | `delete ptr;`       | **必须手动调用** `ptr->~Class();`  |
| **典型用途** | 通用对象创建        | 内存池、硬件映射、高性能缓存       |

### 但是但是但是

简单的回答是：**编译器和运行时系统完全不知道！** 它没有任何内置机制来记录 `buffer` 里哪块地被用了，哪块没被用。

当你从操作系统接管这块内存（buffer）的那一刻起，**所有的“记账”工作（Bookkeeping）全都要靠你自己写代码来完成。**

#### 怎么知道 buffer 哪些被占用了？

既然系统不管，你就必须自己维护一个“游标”指针，或者一个偏移量变量，用来记录“当前用到哪里了”。

❌ 错误做法：盲目覆盖

如果你连续写两行一样的 placement new：

~~~c++
long* p1 = new (buffer) long(10); 
long* p2 = new (buffer) long(20); // 危险！
~~~

`p2` 会直接覆盖在 `p1` 的位置上。前一个对象 `10` 被抹掉了，变成了 `20`。

✅ 正确做法：手动偏移 (Pointer Arithmetic)

你需要手动计算下一个对象的起始地址。通常的做法是：**下一个地址 = 当前地址 + 当前对象的大小**。

~~~c++
#include <new>
#include <iostream>

int main() {
    // 1. 准备一大块地皮 (假设 100 字节)
    char buffer[100]; 
    
    // 定义一个游标指针，一开始指向 buffer 开头
    char* current_ptr = buffer;

    // --- 存放第一个对象 (int) ---
    // 检查空间是否足够 (手动边界检查)
    if (current_ptr + sizeof(int) <= buffer + 100) {
        int* p1 = new (current_ptr) int(123);
        
        // 关键步骤：手动更新游标！
        // 向后移动 int 大小的距离
        current_ptr += sizeof(int); 
        
        std::cout << "p1 放在了偏移量: " << (char*)p1 - buffer << std::endl;
    }

    // --- 存放第二个对象 (double) ---
    // 使用剩下的空间
    if (current_ptr + sizeof(double) <= buffer + 100) {
        // 注意：这里 new 的地址是更新后的 current_ptr
        double* p2 = new (current_ptr) double(3.14);
        
        // 再次更新游标
        current_ptr += sizeof(double);
        
        std::cout << "p2 放在了偏移量: " << (char*)p2 - buffer << std::endl;
    }

    return 0;
}
~~~

#### 知道buffer数组哪里被用了，剩下的元素还要用吗？

我们使用 Placement new 的核心场景通常是 **内存池 (Memory Pool)**。 比如**游戏引擎**一帧内需要创建 1000 个小怪物对象，如果调用 1000 次普通的 `new`，系统要在堆里搜索 1000 次空闲块，非常慢。

**内存池的做法：**

1. **一次性**申请一大块内存（比如 `buffer[1MB]`）。
2. 在这 1MB 里，像上面代码那样，紧挨着一个接一个地 `placement new` 出 1000 个小怪物。
3. 因为是简单的指针加法，速度极快。
4. 一帧结束后，甚至不需要一个个 `delete`，直接把那个 `current_ptr` 指针重置回 `buffer` 的开头，这块内存就算“清空”了，下一帧直接覆盖使用。

#### 关于内存对齐的事情

接简单的 `current_ptr += sizeof(T)` 在某些硬件上会出问题。

**问题：** 许多 CPU 要求 `double` 类型的数据地址必须是 8 的倍数，`int` 必须是 4 的倍数。 如果您的 `buffer` 从地址 `0x1000` 开始：

1. 放了一个 `char` (1字节)。`current_ptr` 变成了 `0x1001`。
2. 接着想放一个 `int` (4字节)。
3. 如果直接在 `0x1001` 处 `new (current_ptr) int`，这叫**未对齐访问**。在 x86 上会变慢，在 ARM 架构上可能会直接崩溃 (Bus Error)。

**专业做法：** 在移动指针时，不仅要加 `sizeof(T)`，还要计算**填充 (Padding)**，确保下一个地址符合该类型的对齐要求。

~~~c++
// 伪代码逻辑
地址 next_addr = current_ptr;
while (next_addr % alignof(int) != 0) {
    next_addr++; // 往前挪一点，直到对齐
}
new (next_addr) int;
~~~

# 命名空间

## 背景 命名冲突

想象一下，你写了一个函数叫 `walk()`。

- 你引入了一个图形库，里面也有个函数叫 `walk()`。
- 你又引入了一个物理引擎库，里面居然还有个函数叫 `walk()`。

这时候编译器就疯了：“你到底想调哪个 `walk`？” 在 C 语言时代，解决办法是加前缀：`my_walk()`, `graphics_walk()`, `physics_walk()`。但这很难看，而且容易出错。

**C++ 的解决方案**：引入“逻辑上的文件夹”——**名称空间**。

## 基础语法

#### 定义名称空间

使用关键字 `namespace`。注意，它必须在全局位置定义（不能在函数里定义）。

~~~c++
namespace Jack {
    double pail;        // 变量
    void fetch() { ... } // 函数
    struct Hill { ... }; // 结构体
}

namespace Jill {
    double fetch; // 不冲突！Jack 有 fetch 函数，Jill 有 fetch 变量
}
~~~

#### 访问成员 (::)

使用 **作用域解析运算符 (Scope Resolution Operator)** `::`。 就像文件路径一样：

- `Jack::pail`  (相当于 `Jack/pail`)
- `Jill::fetch` (相当于 `Jill/fetch`)

#### 开放性

名称空间是“开放”的。你可以随时往已有的名称空间里添加新东西。

~~~c++
// file1.h
namespace Jack { int x; }

// file2.h
// 并没有覆盖 file1，而是把 y "添加" 进了同一个 Jack 空间
namespace Jack { int y; }
~~~

## using声明和using编译指令

#### A. using 声明 (using declaration) —— “只拿我需要的”

它只把名称空间里的**某一个**名字引入当前作用域。

~~~c++
void func() {
    // 声明：我现在要用 Jack 里的 fetch
    using Jack::fetch; 
    
    fetch(); // ✅ 实际上调用的是 Jack::fetch()
}
~~~

**安全性**：**高**。如果你在局部又定义了一个叫 `fetch` 的变量，编译器会**报错**（重定义），提醒你名字冲突了。

#### B. using 编译指令 (using directive) —— “简单粗暴全倒进来”

它把名称空间里的**所有**名字都引入当前作用域。

~~~c++
void func() {
    // 编译指令：把 Jack 所有的家当都倒在桌子上
    using namespace Jack; 
    
    fetch(); // ✅ 调用 Jack::fetch()
    pail = 10; // ✅ 访问 Jack::pail
}
~~~

**安全性**：**低**。

**隐患**：如果局部也有一个叫 `fetch` 的函数，编译器**不会报错**！局部的 `fetch` 会**隐藏**名称空间里的 `fetch`。你会莫名其妙地发现调用的函数不对，debug 都要找半天。

## 头文件using namespace

这是一个新手必犯的禁忌。

**场景**：你写了一个头文件 `myheader.h`，为了图省事，你在里面写了 `using namespace std;`。

**后果**：任何一个包含（`#include`）你这个头文件的人，被迫在他的文件里也引入了整个 `std` 空间！

- 他的代码里可能有个变量叫 `vector`（原本没问题）。
- 因为包含了你的头文件，`std::vector` 突然冲进来了。
- 于是他的代码编译失败了。

**结论：** **头文件中，永远使用完整的 `std::string` 或 `Jack::fetch` 写法。**

## 高级特性：匿名名称空间

这正是我们在 9.2 节学过的 **`static` 全局变量（内部链接性）** 的现代替代品。

~~~c++
// 旧式 C 风格 (Internal Linkage)
static int internal_count = 0;

// 新式 C++ 风格 (Unnamed Namespace)
namespace {
    int internal_count = 0;
}
~~~

**原理**： 编译器在看到匿名名称空间时，会给它生成一个**随机且唯一**的名字（比如 `namespace _UniqueName123`），然后紧接着加上一句 `using namespace _UniqueName123;`。

**效果**： 里面的变量只能在当前文件访问，其他文件无法链接到它（因为没人知道那个随机名字是啥）。C++ 标准推荐使用这种方式来替代 `static` 全局变量。

**为什么说是static的替代品？**

这是 `static` 最大的软肋：**`static` 只能修饰变量和函数，不能修饰类型（类/结构体）。**

假设你在 `a.cpp` 里写了一个辅助类 `Helper`，你不希望 `b.cpp` 看到它，更不希望和 `b.cpp` 里的 `Helper` 类冲突。

尝试用`static`

~~~c++
// ❌ 编译错误！C++ 不允许 static 修饰文件作用域下的 class
static class Helper { 
    void work() {} 
};
~~~

使用匿名名称空间

~~~c++
// ✅ 完美！这个 Helper 类只在当前文件可见
namespace {
    class Helper {
        void work() {}
    };
}
~~~

这是匿名名称空间无可替代的优势。它允许你把一整套逻辑（类、结构体、函数、变量）全部封装在当前文件内部，而不必担心污染全局。

`static` 这个关键字太累了，它身兼数职：

1. 在局部变量前：表示**存储持续性**（静态存储）。
2. 在全局变量前：表示**链接性**（内部链接）。
3. 在类成员前：表示**成员归属**（属于类而非对象）。

（3是什么意思？）

~~~c++
class Student {
public:
    // 普通成员变量 - 属于每个对象
    string name;        // 每个学生有自己的名字
    int age;            // 每个学生有自己的年龄
    
    // static 成员变量 - 属于类
    static int totalStudents;  // 所有学生共享这一个计数
};
~~~

C++ 之父 Bjarne Stroustrup 认为这种重载是不好的设计。引入匿名名称空间，就是为了把“内部链接性”这个职责从 `static` 身上剥离出来，让语义更清晰。

## 底层原理：名称修饰

最后，我们照例看一下底层。编译器是如何区分 `Jack::fetch` 和 `Jill::fetch` 的？

还是靠 **Name Mangling**。

- 源代码：`Jack::fetch()`
- 符号表：`_ZN4Jack5fetchEv` (N 表示 Nested, 4 是 Jack 长度, 5 是 fetch 长度)
- 源代码：`Jill::fetch()`
- 符号表：`_ZN4Jill5fetchEv`

链接器看到的是两个完全不同的字符串，自然就不会搞混了。

## 关于多个匿名名称空间

## 同一个文件中

**可以，但它们其实是同一个。**

在**同一个 `.cpp` 文件**中，如果你写了多个 `namespace { ... }`，编译器会把它们视为**同一个**匿名名称空间的延续。

~~~c++
// main.cpp

namespace {
    int x = 10;
}

// ... 写了一堆其他代码 ...

namespace {
    int y = 20;
}

void func() {
    // x 和 y 都能访问，它们属于同一个"本文件专享"空间
    x = y + 1; 
}
~~~

## 不同文件中

#### 不同文件间：隔离

这是关键！

- `a.cpp` 里的 `namespace { int x; }`
- `b.cpp` 里的 `namespace { int x; }`

虽然看起来一样，但编译器在底层会给它们生成**不同的**唯一名字（Name Mangling）：

- `a.cpp` 的可能叫 `_Unique_A_::x`
- `b.cpp` 的可能叫 `_Unique_B_::x`

**所以它们互不干扰，完全隔离。**

**位置**：匿名名称空间里的变量和全局变量一样，都住在**静态数据区**（`.data` / `.bss`）。

**优势**：它比 `static` 强大，因为它**能封装类和结构体**，而 `static` 做不到。

**数量**：一个文件里写多少个 `namespace { }` 块都可以，它们会自动合并成一个。不同文件的匿名空间则是完全隔离的。