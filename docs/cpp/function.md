此页笔记为《C++ Primer Plus》第七章

# 定义函数

void函数

~~~c++
void functionName(parameterList){
	statement(s);
    return;
}
~~~

有返回值的函数

~~~c++
typeName functionName(parameterList){
    statements;
    return value;
}
~~~

不能返回数组，但是可以将数组作为结构或对象的组成部分返回

函数通常将返回值赋值到指定CPU寄存器或内存单元中随后调用函数查看这个地方

函数在遇到return就会返回

~~~c++
int bigger(int a, int b){
    if(a>b)
        return a;
    else
        return b;
    //与下面一样的
    //if(a>b)
    //	return a;
    //return b;
}
~~~

 ##  函数原型/声明 Function Prototype/Declaration

C++ 编译器按顺序（自上而下）读取文件。如果一个函数在**被调用**时还没有**定义**（或声明），编译器就会因为不知道它是否存在、需要什么参数而报错。

**告知接口：** 它告诉编译器：“有一个名为 `FunctionName` 的函数，它接受一个 `TypeName` 类型的参数，并返回一个 `TypeName` 类型的值。”

**允许调用：** 这样，即使函数的完整定义（函数体）出现在文件**后面**，甚至在**另一个文件**中，编译器也能允许前面的代码调用它。

**类型检查：** 原型允许编译器在函数调用时检查您传入的参数数量和类型是否正确，这确保了程序的**类型安全**。

> 函数声明告诉调用函数，该函数把返回值放到了指定位置（寄存器或内存单元），调用函数将从这个位置取得返回值，因为声明指出了返回值类型，因此编译器直到检索多少个字节并解释。编译器为什么不直接找到函数定义呢？因为编译器可能遇到跨文件的权限问题。

>**编译器专注于编译当前文件，并将查找实际代码的任务留给最后的**链接器。链接器的工作就是根据函数原型留下的标记，将所有分散在不同对象文件中的函数定义连接起来。

~~~c++
typeName FunctionName(ParameterList);
~~~

> 在编译阶段的原型化被称为静态类型检查

# 按值传递与形参实参

~~~c++
// 函数定义：side 是形参
void display(int side) { 
    // ... 函数体使用 side 变量 ...
}

int main() {
    int val = 5;
    
    // 函数调用：val 是实参
    display(val); 
    // ...
}
~~~

实参(argument)是函数**调用**时，在括号中提供给函数的值。

形参(parameter)是函数**定义**时，在括号中声明的变量。

C++默认是**按值传递**的，当按值传递时：

1. 为形参分配一块新的内存空间
2. 将实参的值拷贝一份到形参的内存空间中

函数中的变量是该函数私有的，调用函数时这些变量被分配内存，函数结束时释放内存，这样的变量叫做**局部变量**。

> C++中还有按引用传递和按指针传递。

# 函数与数组

C++与C一样将数组名当作指针，指向数组第一个元素的地址。

> 例外：sizeof得到的是整个数组的长度（单位字节），取地址符&用于数组名时，返回整个数组的地址。

当函数处理数组时

~~~c++
int sum_arr(int arr[], int n)
//int *arr
//int ar[]
//是一样的
~~~

arr不论是数组名还是指针

~~~c++
arr[i] == *(arr+i)
&arr[i] == arr + i
~~~

arr+i并不是在地址上加一个数，而是加了一个与指针指向类型长度的值。

> 这种情况也是按值传递，只不过传递的值是指针。形参复制了实参的指针，所以改的是数组本身。

如果不想让函数改变数组的元素值
~~~c++
void show_array(const double ar[], int n){
    ...
}
~~~

> 指针ar指向的是常量数据，不能使用ar修改数据。并不是说原始数组必须是常量，只是不能在该函数中改数组数据。

## 指针和const

**指针指向的是常量**

~~~c++
int age = 39;
const int *pt= *age;
//age的值可以改 但是不能通过pt改
~~~

指针pt指向一个const int，此时不能用pt来修改修改这个值。

> 并不是说pt指向的值是一个常量，而是对pt而言这个值是常量。

~~~c++
//两种写法是一样的
const int *pt;
int const *pt;
~~~

> const被设计成放在它所修饰的类型名的左边或右边，只要不是最左边

**指针本身是常量**

~~~c++
int * const pt = &age;
*age = 25;//合法
pt = &years;//非法
~~~

常量指针不能指向别的地方，但是可以修改指针内容。

两种写法

~~~c++
const float g_earth = 9.80;
const float* pe = &g_earth;
//合法的
const float g_moon = 1.63;
float * pm = &g_moon;
//非法的
~~~

禁止将const的地址赋给非const指针

**const指针与非const指针赋值**

不能通过赋值解除const

~~~c++
int value = 10;
const int* ptr_const = &value;
int *ptr_none_const = ptr_const;//编译错误
~~~

~~~c++
int value = 10;
int * ptr_none_const = &value;
const int* ptr_const = ptr_none_const;//正确
~~~

~~~c++
const int value = 10;
int *pt = &value;//编译器报错
~~~

| **转换方向**                          | **权限变化**                | **结果**   | **逻辑**                               |
| ------------------------------------- | --------------------------- | ---------- | -------------------------------------- |
| **`const int*` $\rightarrow$ `int*`** | 低权限 $\rightarrow$ 高权限 | **禁止 ❌** | 丢弃了 $\text{const}$ 承诺，不安全。   |
| **`int*` $\rightarrow$ `const int*`** | 高权限 $\rightarrow$ 低权限 | **允许 ✅** | 增加了 $\text{const}$ 限制，是安全的。 |

~~~c++
const int** pp2;
int* p1;
const int n = 13;
pp2 = &p1;	//此处不警告但编译报错不能将int**赋值给const int**
*pp2 = &n;	//语法本身合法
*p1 = 10;	//语法本身合法
p1 = &n;	//此处直接警告无法将const int**转为int**
~~~

上述例子可以看出如果可以将Int**赋值给const int**那么之后可以改const变量，要出事

**只有当一层间接关系时，如指针指向直接数据类型，才能将非const地址赋给const地址**

## 函数与二维数组

在一维数组中

int arr[10]

arr的类型是int*

*arr等价arr[0]

arr+i等价arr[i]

### **二维数组名作为指针**

| **表达式**                 | **含义**                                    | **类型**     | **值**                        |
| -------------------------- | ------------------------------------------- | ------------ | ----------------------------- |
| **`matrix`**               | 整个数组的起始地址，即 **第 0 行** 的地址。 | `int (*)[4]` | 数组首元素的地址              |
| **`matrix[i]`**            | 第 `i` 行的起始地址。                       | `int*`       | 数组 `matrix[i]` 首元素的地址 |
| **`*matrix`**              | 等价于 `matrix[0]`，即 **第 0 行**。        | `int*`       | 第 0 行首元素的地址           |
| **`*(*(matrix + i) + j)`** | 第 `i` 行第 `j` 列元素的值。                | `int`        | `matrix[i][j]` 的值           |

matrix是一个二维数组名，类型是int(*)[4]，matrix的值是第一个元素（第一行）的地址。

解引用*matrix得到所指对象，即第一行matrix[0]。原始类型是一个一维数组，一维数组名是指向第一个元素的指针，所以最终类型是int\*。

1. 数组名 `matrix` 的类型

- `matrix` 是一个二维数组名，它的类型是 $\text{int }(*)[4]$（指向一个包含 4 个 `int` 元素的数组的指针）。
- `matrix` 的值是 **第一个元素（即第 0 行）** 的地址。

2. 解引用 `*matrix` 的结果（得到一个数组名）

- 对 `matrix` 进行解引用 `*matrix`，其结果是它所指向的那个对象，即 **`matrix[0]`**。
- `matrix[0]` 的**原始类型**是一个一维数组 $\text{int}[4]$。

3. 隐式衰退（关键步骤）

- 在 C++ 中，当一个**数组名**（例如 `matrix[0]`）在大多数表达式中使用时，它会**自动隐式地衰退（decay）** 为一个指向其**首元素**的指针。
- `matrix[0]` 的首元素是 `matrix[0][0]`，它的类型是 `int`。
- 因此，`matrix[0]` 衰退成指向 `int` 的指针。

$$\underbrace{*matrix}_{\text{解引用}} \rightarrow \underbrace{matrix[0]}_{\text{数组名 (type: int[4])}} \xrightarrow[\text{隐式衰退}]{\text{C++ 规则}} \underbrace{\&matrix[0][0]}_{\text{首元素地址}} \rightarrow \underbrace{\text{int*}}_{\text{最终类型}}$$

| **表达式**    | **原始类型**       | **隐式转换（衰退）**           | **最终类型**        | **解释**                                  |
| ------------- | ------------------ | ------------------------------ | ------------------- | ----------------------------------------- |
| **`matrix`**  | $\text{int}[3][4]$ | 衰退为指向**第一行**的指针     | $\text{int }(*)[4]$ | 指向一个 4 元素的 $\text{int}$ 数组的指针 |
| **`*matrix`** | $\text{int}[4]$    | 衰退为指向**第一个元素**的指针 | $\text{int}*$       | 指向第 0 行第一个元素的 $\text{int}$ 指针 |

### **int(*)[4]语法说明**

| **步骤**           | **表达式**    | **含义**                                                     |
| ------------------ | ------------- | ------------------------------------------------------------ |
| **1 (内)**         | `p`           | `p` 是一个标识符（变量名）。                                 |
| **2 (优先级最高)** | `(*p)`        | **`p` 是一个指针**。圆括号保证 `p` 首先与 `*` 结合，确定 `p` 的本质是一个指针。 |
| **3 (右)**         | `(*p)[4]`     | `p` 是一个指针，它指向一个有 `4` 个元素的**集合**（一个数组）。 |
| **4 (左)**         | `int (*p)[4]` | 这个集合（这个数组）的元素类型是 `int`。                     |

> p是一个指向包含四个int元素的指针

| **数组索引语法**   | **指针语法（等价）**   | **解释**                                                     |
| ------------------ | ---------------------- | ------------------------------------------------------------ |
| **`matrix[i]`**    | `*(matrix + i)`        | 将行指针 `matrix` 向后移动 `i` **行**（即 $\text{i} \times \text{Row Size}$ 字节）。得到第 `i` 行的首地址。 |
| **`matrix[i][j]`** | `*(*(matrix + i) + j)` | 1. `*(matrix + i)` 得到第 `i` 行。2. 再将这个地址向后移动 `j` **个元素**（即 $\text{j} \times \text{Element Size}$ 字节）。最后解引用得到值。 |

### 数组指针和指针数组

| **声明**          | **名称**     | **含义**                                                     | **内存布局**                                                 |
| ----------------- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **`int (*p)[4]`** | **数组指针** | `p` 是一个指针，它指向一整块包含 4 个 `int` 的内存区域。     | `p` 只占用一个指针大小的内存，但 `p+1` 会跳过 4 个 `int` 的距离。 |
| **`int *p[4]`**   | **指针数组** | `p` 是一个包含 4 个元素的数组，**每个元素**都是一个 `int*` 指针。 | `p` 占用 4 个指针大小的内存。                                |

### int p\[][4]的语法说明

`int p[][4]` 实际上是 `int (*p)[4]` 的**等价语法糖**

`int p[][4]` 和 `int (*p)[4]` 在作为函数形参时，意义是**完全相同**的。它们都声明了一个指向 $\text{int}[4]$ 数组的指针。

# 函数指针

函数指针的核心思想是：**代码也是位于内存中的数据**

当写下 `int braincount = 5;` 时，`5` 存储在内存的某个位置。 同样，当定义一个函数 `void think() { ... }` 时，这个函数的**二进制机器指令**也被加载到了内存的某个连续区域中。

**函数的地址：** 这个指令序列开始的那个内存地址（入口地址），就是**函数的地址**。

**函数指针：** 就是一个专门用来存储这个“入口地址”的变量。

## 声明：函数指针

~~~c++
double pam(int lines);//pam接受int 返回double

double *pf(int);//❌定义了一个函数 接受int 返回double*
//以为()优先级高于*

double (*pf)(int);//✅括号(*pf)强制结合
~~~

**解析 `double (*pf)(int)`：**

1. `(*pf)`：`pf` 是一个指针。
2. `(*pf)(int)`：这个指针指向一个函数，该函数接受一个 `int` 参数。
3. `double (*pf)(int)`：这个函数的返回类型是 `double`

> **⚠️ 必须匹配：** 指针的**返回类型**和**参数列表**（特征标）必须与目标函数完全一致。

## 赋值：获取函数地址

~~~c++
//返回类型 (*变量名)(参数列表)
double pam(int);
double (*pf)(int); // 声明

pf = pam;  // ✅ 写法 1：直接使用函数名
pf = &pam; // ✅ 写法 2：显式取地址（效果一样）
~~~

**C++ 规则：** 类似于数组名，**函数名**在大多数情况下会被隐式转换为**函数的地址**。所以 `pam` 和 `&pam` 通常是通用的。

## 使用：通过指针调用函数

现在 `pf` 指向了 `pam`，我们可以通过 `pf` 来调用函数。

**方法一：解引用调用**

`pf` 是指针，`*pf` 就是函数本身，`(*pf)(5)` 就是调用函数，完美对应声明语法 `double (*pf)(int)` 。

~~~c++
double x = (*pf)(5);
~~~

**方法二：直接调用**

 C++ 允许把函数指针当做函数名直接使用

~~~c++
double y = pf(5);
~~~

## 使用场景

函数指针为了**通用性**

~~~c++
#include <iostream>

// 1. 定义两个特征标相同的函数
double betsy(int lns) {
    return 0.05 * lns;
}

double pam(int lns) {
    return 0.03 * lns + 0.0004 * lns * lns;
}

// 2. 定义一个接受“函数指针”作为参数的函数
// 参数 pf 是一个指针，指向 "double xxx(int)" 类型的函数
void estimate(int lines, double (*pf)(int)) {
    // 通过指针调用传入的函数
    std::cout << lines << " lines will take ";
    std::cout << (*pf)(lines) << " hour(s)\n"; 
}

int main() {
    int code_lines = 1000;

    std::cout << "Using Betsy's method:\n";
    // 3. 传递函数名作为参数（传递的是地址！）
    estimate(code_lines, betsy); 

    std::cout << "Using Pam's method:\n";
    estimate(code_lines, pam);

    return 0;
}
~~~

## 使用auto和typedef

~~~c++
// 给 "指向 double(int) 的指针类型" 起个别名叫 PF
typedef double (*PF)(int); 
// 或者 C++11 写法（更推荐）：
using PF = double (*)(int);

PF p1 = pam;
void estimate(int lines, PF pf);
~~~

~~~c++
auto p2 = pam; // C++11后编译器自动推断 p2 的类型是 double (*)(int)
~~~

| **特性**     | **数组名 (arr)**                                          | **函数名 (func)**                                            |
| ------------ | --------------------------------------------------------- | ------------------------------------------------------------ |
| **定义**     | `int arr[10];`                                            | `void func();`                                               |
| **本质**     | 是一块连续数据的**标识符**。                              | 是一段连续代码指令的**标识符**。                             |
| **隐式转换** | 在表达式中，**隐式衰退**为指向**首元素**的指针 (`int*`)。 | 在表达式中，**隐式转换**为指向**函数本身**的指针 (`void(*)()`)。 |
| **例外情况** | `sizeof(arr)` (求整个数组大小) `&arr` (求整个数组指针)    | `&func` (虽然结果也是指针，但语义上是显式取址) `sizeof` 通常对函数非法。 |

| **特性**        | **数组名 (arr)**               | **函数名 (func)**                    |
| --------------- | ------------------------------ | ------------------------------------ |
| **本质**        | 指向数据区的内存地址           | 指向代码区的内存地址                 |
| **隐式转指针**  | ✅ 是 (`int*`)                  | ✅ 是 (`void (*)(int)`)               |
| **取地址 `&`**  | `&arr` 类型变了 (`int (*)[N]`) | `&func` 类型通常被视为等价           |
| **解引用 `\*`** | `*arr` 得到首元素              | `*func` 得到函数本身（又可转为指针） |
| **指针运算**    | ✅ `arr + 1` 合法               | ❌ `func + 1` **非法**                |
