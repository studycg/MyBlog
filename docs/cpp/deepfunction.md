本本章对应《C++ Primer Plus》第8章函数探幽

# 内联函数

普通函数调用时会发生：

CPU 需要做：

1. **记录当前位置**（将返回地址压入栈）。
2. **保护现场**（将当前的寄存器值压入栈）。
3. **传递参数**（将实参复制到栈或寄存器）。
4. **跳转**（Jump）到函数的内存地址执行代码。
5. **执行完后**，恢复现场，弹出栈，**跳转**回原来的位置。

这个处理有点像408中操作系统中的中断处理。

但如果**函数非常小**，那么以上操作困难比真实执行语句花费时间还要多，于是有了内联函数，直接将函数定义写在正文中。

## **以空间换时间**

~~~c++
// 定义内联函数
inline double square(double x) {
    return x * x;
}

int main() {
    double a = 5.0;
    double b = square(a); // 调用处
    return 0;
}
~~~

直接变为了

~~~c++
// 编译器眼中的 main 函数（逻辑上）：
int main() {
    double a = 5.0;
    double b = a * a; // 直接替换，没有函数跳转
    return 0;
}
~~~

| **特性**  | **描述**                                                     |
| --------- | ------------------------------------------------------------ |
| **优点 ** | 1. **速度快**：省去了参数压栈、跳转、返回等开销。 2. **优化机会**：编译器可以结合上下文对代码进行进一步优化（例如常量折叠）。 |
| **缺点 ** | 1. **代码膨胀 (Code Bloat)**：如果函数体很大，且被调用了 100 次，代码就会被复制 100 份，导致最终的 `.exe` 文件变大。 2. **缓存命中率降低**：如果程序体积太大，无法完全装入 CPU 的高速缓存 (Cache)，反而可能导致运行变慢。 |

## 内联函数规则

### **与编译器**

内联函数只是建议，若结构复杂或包含递归编译器会将内联函数看为普通函数

### **内联函数与头文件**

**普通函数**：声明放 `.h`，定义放 `.cpp`。

**内联函数**：**定义通常直接放在 `.h` 头文件中。**

编译器在编译调用该函数的 `.cpp` 文件时，必须能看到函数的**具体实现代码**（函数体），才能把它“复制粘贴”进去。如果只有声明，编译器就无法进行内联展开。

### 类内部定义的函数默认是内联的

在 C++ 类（Class）中，如果您直接在类声明的大括号内部定义函数（通常是简短的 `get/set` 函数），编译器会自动将其视为 `inline`，无需显式写关键字。

~~~c++
class Account {
public:
    // 隐式内联 (Implicit Inline)
    double getBalance() { return balance; } 
private:
    double balance;
};
~~~

### 内联与宏

在 C 语言时代，人们用 `#define` 宏来实现类似的功能。但 C++ 强烈建议使用 `inline` 代替宏。

**宏的危险 (`#define SQUARE(X) X*X`)：** 它是**文本替换**，不进行类型检查，容易出错。

~~~c++
#define SQUARE(X) X*X

int a = 5;
int b = SQUARE(a + 1); 
// 宏展开结果： 5 + 1 * 5 + 1 
// 计算结果：5 + 5 + 1 = 11 (期望是 36)
// 必须写成 ((X)*(X)) 才能避免
~~~

**内联函数的安全：** 它是**真正的函数**。编译器会检查参数类型，计算参数值，然后再传递。

~~~c++
inline int square(int x) { return x * x; }

int b = square(a + 1); 
// 先计算 a+1=6，再传给 x，结果 36。安全！
~~~

# 引用变量

引用就是给变量起一个别名，本身不储存新数据，是已有变量的另一个名字。

~~~c++
int rats = 101;
int & rodents = rats; // rodents 是 rats 的引用
~~~

## 引用的三个规定

1. 引用必须初始化 不能创建空引用
2. 一旦引用初始化指向了某个变量，它就永远绑定在此变量上了
3. 没有空引用 必须指向对象

## 作用

按值传递形参只是副本

~~~c++
void swap(int a, int b) { // a, b 是副本
    int temp = a;
    a = b;
    b = temp;
} // 函数结束，副本销毁，原值没变
~~~

按指针传递比较繁琐

~~~c++
void swap(int *a, int *b) { // 接收地址
    int temp = *a; // 需要解引用
    *a = *b;
    *b = temp;
}
// 调用：swap(&x, &y); // 需要取地址
~~~

按引用传递

~~~c++
void swap(int &a, int &b) { // a 是 x 的别名，b 是 y 的别名
    int temp = a;
    a = b;
    b = temp;
}
// 调用：swap(x, y); // 代码像按值传递一样干净，但效果是修改原值！
~~~

## 底层实现

在汇编层面 编译器通常将引用实现为`const`指针

| **概念**     | **代码**      | **编译器眼中的等价实现** |
| ------------ | ------------- | ------------------------ |
| **定义引用** | `int &r = x;` | `int * const r = &x;`    |
| **使用引用** | `r = 10;`     | `*r = 10;` (自动解引用)  |

## const引用

在函数参数中经常看到const引用

~~~c++
// 效率高（不拷贝），且安全（保证不修改 source）
void printData(const std::string & source);
~~~

**const 引用的特殊能力：** 普通的引用（非 `const`）只能绑定到**左值（具体的变量）**。但 `const` 引用可以绑定到**临时值（右值）**。

int & a = 10;       // ❌ 错误！10 是字面量，没有地址，不能被非 const 引用指向。
const int & b = 10; // ✅ 正确！

**编译器背后的操作：** 当编译器看到 `const int & b = 10;` 时，它会偷偷创建一个临时的匿名变量存 10，然后让 `b` 指向这个临时变量。这对函数传参非常有用（允许你传 `func(10)` 而不仅仅是 `func(x)`）。

| **特性**           | **指针 (\*)**                    | **引用 (&)**                         |
| ------------------ | -------------------------------- | ------------------------------------ |
| **是否必须初始化** | 否（可以是野指针）               | **是**（必须绑定）                   |
| **能否改变指向**   | 能（可以指向不同变量）           | **不能**（从一而终）                 |
| **能否为空**       | 能 (`nullptr`)                   | **不能**                             |
| **语法**           | 需要 `*` 解引用，`->` 访问成员   | 直接像普通变量一样使用，`.` 访问成员 |
| **主要用途**       | 动态内存管理、数组操作、底层操作 | 函数参数传递、运算符重载、作为别名   |

## 引用的属性和特点

~~~c++
double cube(double a);

double refcube(double &ra);

int main(){
	using namespace std;
    double x = 3.0;
    cout << cube(x);
    cout << x << endl;//3
    cout << refcube(x);
    cout << x << endl;//27
    return 0;
}
double cube(double a){
    a* = a*a;
    return a;
}
double refcube(double &ra){
    a* = a*a;
    return a;
}
~~~

若要实现这种功能请不要传递引用

**按值传递与按引用传递与表达式**

~~~c++
double z = cube(x+20);
z = cube(8.0);
int k = 10;
z = cube(k);
double yo[3]={2.2,3.3,4.4}
z = cube(yo[2]);
//上面的写法在按值传递里都是OK的
~~~

~~~c++
double z = refcube(x+3.0);
~~~

编译不通过：x+3.0不是double类型的变量，因此程序将创建一个临时无名变量。将其初始化为x+3.0的值。`refcube`中的`ra`成为该临时变量的引用。

**当实参与引用参数不匹配，C++将生成临时变量**

目前仅当参数为const引用时，C++才允许这样做。

### 实参与左值

引入const之前

**左值：**被引用的数据对象：变量、数组元素、结构成员、引用和解除引用的指针。（可在赋值语句左边的实体）

**非左值：**字面常量（引号字符串除外）、包含多项式的表达式。

引入const之后

常规变量与const变量都可被视为左值，因为可以通过地址访问。常规变量属于可修改的左值，const变量属于不可修改的左值。

**如果引用参数是const，那么编译器在下面情况会生成临时变量：**

1. 实参的类型正确但不是左值
2. 实参的类型不正确但可以转换为正确的类型

~~~c++
double refcube(const double &ra){
    return ra*ra*ra;
}
~~~

~~~c++
double side = 3.0;
double *pd = &side;
double & rd = side;
long edge = 5L;
double lens[4] = {2.0, 5.0, 12.0, 12,0};
double c1 = refcube(side);		//ra is side
double c2 = refcube(*pd);		//ra is *pd is side
double c3 = refcube(rd);		//ra is rd is side
double c4 = refcube(lens[2]);	//ra is lens[2]
double c5 = refcube(edge);		//ra is temporary variable
double c6 = refcube(7.0);		//ra is temporary variable
double c7 = refcube(side+10.0);	//ra is temporary variable
~~~

side/lens[2]/rd/*pd都是有名称的数据对象，因此可以为其创建引用。

edge是变量类型不一样，7.0和side+10.0类型正确但没名称，此时编译器生成一个匿名变量并让ra指向。**这些临时变量只在函数调用期间存在，此后编译器可以随意删除**

~~~c++
void swapr(int &a, int &b){
    int temp;
    temp = a;
    a = b;
    b = temp;
}

long a = 3, b = 5;
swapr(a,b);
~~~

此时类型不匹配，编译器生成两个临时int变量，初始化为3和5，之后交换临时变量的内容。a和b值保持不变。

这种实参不匹配的零时变量政策有点像按值传递。

### 右值引用

这个之后讲

## 引用用于结构体

~~~c++
struct goods{
    std::string name;
    int made;
    int attempts;
    float percent;
};

void set_pc(goods & ft);
void display(const goods & ft);//不希望函数修改传入的结构体
~~~

## 返回引用

传统返回机制与函数参数按值传递类似，计算关键字return后的表达式，并将结果返回给调用函数。这个值被复制到一个**临时位置**，调用程序将从临时位置拿走数据。

~~~c++
double m = sqrt(16.0);//1
cout << sqrt(25.0);//2
~~~

在1中4.0被复制到临时位置，之后被复制给m。

在2中5.0被复制到临时位置，之后传递给cout。

如果返回的是结构体，那么会把整个结构体复制到临时位置，并将拷贝复制给调用函数。

### **返回引用的主要目的：**

1. **效率：** 如果函数返回的是一个巨大的结构体或类对象，复制一份是非常昂贵的。返回引用就是直接把原本的对象“递”出去，**没有复制过程**。
2. **作为左值：** 这是最神奇的地方。如果一个函数返回引用，那么**这个函数调用表达式本身可以出现在赋值号的左边！**

~~~c++
#include <iostream>

// 返回 double 的引用
double & getVal(double * arr, int i) {
    return arr[i]; // 直接返回数组中那个元素的“别名”
}

int main() {
    double data[3] = {1.1, 2.2, 3.3};

    std::cout << "Original: " << data[1] << std::endl;

    // 🤯 魔法时刻：给函数调用赋值！
    getVal(data, 1) = 99.9; 

    // 实际上等价于：data[1] = 99.9;
    std::cout << "Modified: " << data[1] << std::endl;

    return 0;
}
~~~

因为 `getVal` 返回的是 `arr[1]` 的引用（也就是 `arr[1]` 那个内存块本身），所以我们可以直接往里面写入 `99.9`。

### 致命陷阱：返回局部变量的引用

**规则：永远不要返回函数内部局部变量（Local Variable）的引用。**

~~~c++
int & badFunction() {
    int secret = 42; // secret 是局部变量，存在于栈内存中
    return secret;   // 试图返回它的引用
} // 函数结束，secret 的内存被系统回收（销毁）

int main() {
    int & result = badFunction(); 
    // result 现在是一个“悬空引用” (Dangling Reference)
    // 它指向了一块已经被标记为“废弃”的内存。
    
    // 此时访问 result，可能得到 42，也可能得到乱码，或者程序崩溃。
    // 这叫“未定义行为” (Undefined Behavior)。
    return 0;
}
~~~

那该怎么做呢？
**通常是传递 给函数的引用参数**

~~~c++
// 接收 target 的引用，修改它，并再次返回它的引用
int & accumulate(int & target, int val) {
    target = target + val;
    return target; // 安全！target 也是外面的变量，函数结束时它还在。
}

int main() {
    int score = 10;
    // 链式调用 (Chaining)
    accumulate(score, 5) = 100; // 先加5变成15，然后因为返回引用，又被赋值成100
    // 甚至可以：
    // accumulate(accumulate(score, 5), 10);
}
~~~

这也是 C++ 中 `cout << "Hello" << "World";` 能连续写的原理（`<<` 运算符返回了 `cout` 对象的引用）。

~~~c++
const double & getConstVal(const double * arr, int i) {
    return arr[i];
}

// 调用：
// double x = getConstVal(data, 1); // ✅ 可以读取
// getConstVal(data, 1) = 99.9;     // ❌ 编译错误！不能给 const 引用赋值
~~~

常规返回值是右值：不能通过地址访问的值，位于临时内存单元，运行到下一条语句时它们可能不存在。

引用返回值是左值：左值必须标识一个可修改的内存块。

**优势**：效率高（无拷贝），可以实现链式编程，可以作为左值。

**红线**：**绝对不要返回局部变量的引用**（这就是野指针/悬空引用）。

**原则**：你返回的引用，它所指向的那个变量，其**寿命**必须比函数调用的时间更长。

### const 引用返回值

有时候为了效率，想返回引用（避免拷贝），但又**不想**让别人像上面那样修改它（`func() = 100;` 看起来很怪，容易出错）。

~~~c++
const double & getConstVal(const double * arr, int i) {
    return arr[i];
}

// 调用：
// double x = getConstVal(data, 1); // ✅ 可以读取
// getConstVal(data, 1) = 99.9;     // ❌ 编译错误！不能给 const 引用赋值
~~~

# 默认参数

默认参数是指当函数调用中省略了实参时自动使用的一个值

默认参数必须通过函数声明来写

~~~c++
char * left(const char*str, int n = 1);
~~~

对于带参数列表的函数必须从右向左添加默认值，**要为某个函数设置默认值，则必须为它右边的所有参数提供默认值**

~~~c++
int harpo(int n, int m= 4, int j = 5);//合法
int chico(int n, int m=6, int j);//非法
int groucho()int k = 1, int m = 2, int n = 3);//合法
~~~

实参按照从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。

~~~c++
int beeps = harpo(3, , 8);//非法
~~~

# 函数重载

函数重载的关键是参数列表

如果两个函数的**参数数目**和**类型**相同，同时**参数的排列顺序**也相同，则它们的**特征标**相同，而**变量名是无关紧要的**。 

**特征标**是指函数的**参数列表**，包括：

1. 参数的**个数**。
2. 参数的**类型**。
3. 参数的**顺序**。

**注意：** 函数的**返回类型**不是特征标的一部分

## 编译器眼中的重载

在编译过程中，编译器会执行一种叫做**名称修饰 (Name Mangling)** 的操作。它会根据**特征标**，把函数名“偷偷”改写成内部唯一的标识符。

- `long MyFunc(int, float)` 可能被改写为 `?MyFunc@@YAJHf@Z` (举例)
- `long MyFunc(float, int)` 可能被改写为 `?MyFunc@@YAJMf@Z`

对编译器来说，这根本就是两个完全不同的函数，只是对我们人类来说名字一样而已。

## ✅ 哪些情况算重载？

只要**特征标**不同，就可以重载。

~~~c++
void print(int a);               // 原始函数
void print(const char * str);    // ✅ 重载：参数类型不同
void print(double a, int b);     // ✅ 重载：参数个数不同
void print(int a, double b);     // ✅ 重载：参数顺序不同 (与上一行相比)
~~~

## ❌ 哪些情况**不算**重载

### 1.只有返回类型不同

~~~c++
int  calc(int a);
void calc(int a); // ❌ 错误：特征标相同
~~~

**为什么？** 因为在 C++ 中，可以调用函数但忽略其返回值：

~~~c++
calc(10);
~~~

如果编译器允许上述重载，这行代码该调用哪个 `calc` 呢？编译器无法判断，所以直接禁止。

### 2.引用与值的混淆

虽然语法上允许定义，但会在调用时报错。

~~~c++
void func(double x);       // 接受值
void func(double & x);     // 接受引用

// 编译可以通过，但在调用时...
double val = 3.14;
func(val); // ❌ 错误：二义性 (Ambiguous)
~~~

**原因：** `val` 既匹配按值传递（拷贝一份），也匹配按引用传递。编译器不知道想用哪个，所以报错。

## ⚖️ 重载 vs 默认参数

**场景：** 我们想让一个函数既可以接受 1 个参数，也可以接受 2 个参数。

**方法 A：使用重载**

```c++
void bite(int num);
void bite(int num, int force);
```

**方法 B：使用默认参数**

```c++
void bite(int num, int force = 10);
```

**如何选择？**

- 如果执行的逻辑**完全不同**（例如，一个参数是求圆面积，两个参数是求矩形面积），用**重载**。
- 如果逻辑是一样的，只是缺少参数时使用默认值，用**默认参数**（代码更少）。

> [!CAUTION]
>
> **不要同时使用！** 如果您同时定义了上面两种情况，调用 `bite(5)` 时，编译器会崩溃，因为它不知道是调用“单参数的重载版本”还是“带默认参数的双参数版本”。

## 关于名称修饰

### 为什么C语言不支持修饰？

在 C 语言中，函数名在编译后的**符号表 (Symbol Table)** 中是直接对应的。

- 代码：`void func(int x) {}`
- 编译器生成的符号：`_func`

如果您再写一个 `void func(double x)`，编译器生成的符号还是 `_func`。链接器（Linker）在最后组装程序时，看到两个一模一样的 `_func`，就会报错：“符号重定义”。

### 为什么C++支持？

为了支持重载，C++ 编译器会将**函数的参数类型信息**编码进最终的符号名中。这样，即使函数名相同，只要参数不同，它们在符号表中就是**完全不同**的名字。

#### 实验演示 (假设使用 GCC/Clang 编译器规则)

假设我们有两个重载函数：

~~~c++
void bite(int x);
void bite(double x);
~~~

编译器会将它们变为：

| **原始函数签名**      | **编译器生成的符号 (Mangled Name)** | **解码含义**                                                 |
| --------------------- | ----------------------------------- | ------------------------------------------------------------ |
| `void bite(int)`      | **`_Z4bitei`**                      | `_Z` (前缀) + `4` (函数名长度) + `bite` (函数名) + **`i`** (参数类型 int) |
| `void bite(double)`   | **`_Z4bited`**                      | `_Z` (前缀) + `4` (函数名长度) + `bite` (函数名) + **`d`** (参数类型 double) |
| `void bite(int, int)` | **`_Z4biteii`**                     | ... + **`ii`** (两个 int)                                    |

**MSVC (Visual Studio) 的风格不同**，它可能会变成 `?bite@@YAXH@Z` 这样的乱码，但原理是一样的：**把参数类型编码进名字里**。

所以，**在机器码（底层）的世界里，根本不存在“重载”这回事。** 所有的函数都是独一无二的，只是编译器帮我们做了一层“自动改名”的工作，让我们在写代码时感觉它们叫同一个名字。

# 函数模板

如果说**函数重载**是让你可以用同一个名字做**相似**的事（针对不同类型），那么**函数模板**就是为了让你**只写一次代码**，就能处理**所有**类型。

这是 **泛型编程 (Generic Programming)** 的基石。

## 1. 为什么我们需要模板？（痛点分析）

想象一下，我们需要写一个交换两个变量值的 `Swap` 函数。

在没有模板的时候，利用刚刚学过的**函数重载**，我们得这样写：

~~~c++
void Swap(int &a, int &b) { ... }       // 处理 int
void Swap(double &a, double &b) { ... } // 处理 double
void Swap(char &a, char &b) { ... }     // 处理 char
// ... 如果要处理自定义的 Student 类，还得再写一遍
~~~

**痛点：** 这里的逻辑代码（`temp = a; a = b; b = temp;`）是完全重复的！这违反了编程界最高的 **DRY (Don't Repeat Yourself)** 原则。如果逻辑要修改，你得改几十个地方。

## 2. 什么是模板

**函数模板**实际上**不是**一个真正的函数。它是生成函数的**蓝图 (Blueprint)** 或 **模具**。

编译器只有在看到你**实际调用**它的时候，才会根据你传进去的类型，临时为你造出一个真正的函数。

### 语法定义

我们需要告诉编译器：“我接下来的这个函数，里边的类型是不确定的，我用一个占位符 `T` 来代替。”

~~~c++
// template <typename T> 也是合法的，typename 和 class 在这里完全通用
template <class T>  
void Swap(T &a, T &b) {
    T temp; // temp 的类型也是 T
    temp = a;
    a = b;
    b = temp;
}
~~~

`template <class T>`：这是模板头。告诉编译器，下面代码里如果出现了 `T`，它不是一个具体的类型，而是一个**泛型变量**。

## 3. 底层原理：实例化

编译器在底层到底做了什么？

~~~c++
int i = 10, j = 20;
Swap(i, j);  // 调用 1

double x = 24.5, y = 81.7;
Swap(x, y);  // 调用 2
~~~

### 编译器的“幕后操作”流程：

1. **扫描 (Scanning)**：编译器读到 `Swap(i, j)`。它发现 `i` 和 `j` 是 `int` 类型。

2. **查找 (Lookup)**：它找到了 `Swap` 的模板定义。

3. **推导 (Deduction)**：编译器推断出占位符 `T` 应该等于 `int`。

4. **生成 (Generation)**：编译器在**编译期间**，悄悄地在后台生成了一份**专门针对 int** 的函数代码。这个过程叫 **实例化 (Instantiation)**。

   - 生成的隐式代码大致如下：

   ~~~c++
   void Swap_int(int &a, int &b) { 
       int temp = a; a = b; b = temp; 
   }
   ~~~

5. **第二次生成**：当读到 `Swap(x, y)` 时，编译器发现 `T` 应该是 `double`，于是它又生成了另一份专门针对 `double` 的函数代码。

### 核心结论（兼具深度与广度）

1. **代码膨胀 (Code Bloat)**： 使用模板并不会神奇地让二进制代码变小。恰恰相反，如果您用 `int`、`double`、`float`、`string` 调用了四次 `Swap`，编译器就会在最终的 `.exe` 文件里生成**四个**完全不同的函数体。
   - **好处**：执行效率极高（和手写的一样快，没有运行时开销）。
   - **坏处**：可执行文件体积变大。
2. **静态多态 (Static Polymorphism)**： 通常我们说的多态（虚函数）是运行时的。而模板被称为**编译时多态**。所有的类型判断和代码生成都在编译的那一瞬间完成了。
3. **强类型安全**： 模板不是简单的文本替换（那是 C 语言的 `#define` 宏）。模板是类型安全的。如果您试图 `Swap(int, double)`，编译器推导 `T` 时会发现冲突（一个是 int，一个是 double），直接报错，而不是在运行时崩溃。

## 4. 局限性与显式具体化

假设我们有一个 `struct Job`：

~~~c++
struct Job {
    char name[40];
    double salary;
    int floor;
};
~~~

如果我们调用 `Swap(jobA, jobB)`，模板生成的代码会交换整个结构体。 **但是**，如果我们只想交换 `salary` 和 `floor`，不想交换 `name` 怎么办？通用的模板（直接赋值）无法满足这个特殊需求。

### 解决方案：显式具体化

我们可以告诉编译器：“对于大多数类型，你用那套通用的蓝图；但**如果 T 是 Job 类型**，请务必使用我下面写的这套专门的代码。”

~~~c++
// 1. 通用模板
template <typename T>
void Swap(T &a, T &b);

// 2. 显式具体化 (针对 Job 类型)
template <> void Swap<Job>(Job &j1, Job &j2) {
    // 自定义交换逻辑：只交换工资
    double t1 = j1.salary;
    j1.salary = j2.salary;
    j2.salary = t1;
    
    int t2 = j1.floor;
    j1.floor = j2.floor;
    j2.floor = t2;
    // name 不动
}
~~~

### 编译器匹配顺序（优先级）

当编译器遇到 `Swap(j1, j2)` 时，它的查找顺序是：

1. **非模板函数**（如果有普通的 `void Swap(Job&, Job&)`）：**优先级最高**。编译器认为你手写的肯定是最好的。
2. **显式具体化模板**（`template <> void Swap<Job>...`）：**优先级第二**。
3. **通用模板**（`template <class T> ...`）：**优先级最低**。只有上面都没找到，才去用蓝图现造。

# decltype关键字

在不知道变量值的情况下，如何获取变量的精确类型？

## decltype 的核心作用：类型捕获

我们之前学过 `auto`，它通过变量的**初始值**来推导类型：

~~~c++
auto x = 10 + 3.14; // x 的初始值是 13.14，所以 x 是 double
~~~

但是，有时候我们只需要**表达式的类型**，而不是它的值，尤其是在编写**泛型代码（如模板）**时。`decltype` 正是为了这个目的而生的。

- **`decltype(expression)`**：它的作用是返回 `expression` **的类型**，而不是去计算它的值。

~~~c++
int x = 5;
double y = 3.14;

// 1. 获取变量的类型
decltype(x) z; // z 的类型是 int (等价于 int z;)

// 2. 获取表达式的类型
decltype(x + y) w; // x + y 的结果是 double，所以 w 的类型是 double
~~~

## 返回类型后置

C11之前，编写一个返回两个未知类型相加结果的函数模板非常困难，因为你无法预知 `T1 + T2` 究竟会产生 `T1`、`T2` 还是全新的类型。

~~~c++
// ❌ 错误或困难：返回类型是什么？
template <typename T1, typename T2>
? magic_add(T1 x, T2 y) {
    return x + y;
}
~~~

### `decltype` 结合尾置返回类型 (C++11)

C++11 引入了**尾置返回类型**的语法，允许我们将返回类型放在参数列表的后面，这使得我们可以在参数 `x` 和 `y` 已经被引入作用域后，再用 `decltype` 来推导它们的组合类型。

```c++
template <typename T1, typename T2>
auto magic_add(T1 x, T2 y) -> decltype(x + y) {
    return x + y;
}
```

- **`auto` 的作用：** 仅仅作为占位符，表示我们将使用尾置返回类型。

- **`-> decltype(x + y)` 的作用：** 告诉编译器，这个函数的真正返回类型是 `x + y` 这个表达式的类型。

例如，如果调用 `magic_add(5, 3.14)`，那么 `x` 是 `int`，`y` 是 `double`，`decltype(x + y)` 会推导出 `double`。

## decltype的复杂规则推导注意的问题

`decltype` **一般不会像 `auto` 那样忽略引用和 `const`**

### 1.变量名

~~~c++
const int x = 5;
const int &r = x;

decltype(x) a;    // a 的类型是 const int
decltype(r) b = x; // b 的类型是 const int& (必须初始化)
~~~

### 2.非括号表达式

~~~c++
decltype(10) c;       // c 的类型是 int
decltype(x + y) d;    // d 的类型是 double
~~~

### 3.带括号的左值表达式

| **表达式**          | **类型推导**     | **结果类型**     | **解释**                                         |
| ------------------- | ---------------- | ---------------- | ------------------------------------------------ |
| `decltype(x)`       | 变量名           | `const int`      | 遵守规则 1                                       |
| **`decltype((x))`** | **带括号的左值** | **`const int&`** | C++ 规定：任何带括号的左值表达式都被视为引用类型 |
| `decltype(x + y)`   | 右值             | `double`         | 遵守规则 2                                       |
| `decltype((x + y))` | 右值             | `double`         | 即使加了括号，`x+y` 结果仍然是右值               |

**为什么 `decltype((x))` 会是引用？** C++ 标准要求，这种带括号的左值表达式表示对一个**容器**的访问，即它代表一个**位置**。在 C++ 类型系统中，**位置**的类型通常以引用的形式表示。

~~~c++
int x = 10;

decltype(x) a = 20;     // a 是 int
decltype((x)) b = x;    // b 是 int&（注意：这里不同！）

// decltype(变量) 返回变量的声明类型
// decltype((变量)) 返回表达式类型（如果表达式是左值，则返回引用）
~~~

